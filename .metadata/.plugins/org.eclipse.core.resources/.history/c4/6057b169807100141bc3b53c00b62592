#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <errno.h>
#include "hurl_core.h"
#include <string.h>
#include <netinet/in.h>
#include <unistd.h>
#include <math.h>
#include <sys/resource.h>
#include "playback.h"
#include <fcntl.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

int OpenListener(int port) {
}

/* initialize SSL server  and create context  */
SSL_CTX* InitServerCTX(void) {
	SSL_METHOD *method;
	SSL_CTX *ctx;

	OpenSSL_add_all_algorithms(); /* load & register all cryptos, etc. */
	SSL_load_error_strings(); /* load all error messages */
	method = SSLv2_server_method(); /* create new server-method instance */
	ctx = SSL_CTX_new(method); /* create new context from method */
	if (ctx == NULL) {
		ERR_print_errors_fp(stderr);
		abort();
	}
	return ctx;
}

void LoadCertificates(SSL_CTX* ctx, char* CertFile, char* KeyFile) {
	/* set the local certificate from CertFile */
	if (SSL_CTX_use_certificate_file(ctx, CertFile, SSL_FILETYPE_PEM) <= 0) {
		ERR_print_errors_fp(stderr);
		abort();
	}
	/* set the private key from KeyFile (may be the same as CertFile) */
	if (SSL_CTX_use_PrivateKey_file(ctx, KeyFile, SSL_FILETYPE_PEM) <= 0) {
		ERR_print_errors_fp(stderr);
		abort();
	}
	/* verify private key */
	if (!SSL_CTX_check_private_key(ctx)) {
		fprintf(stderr, "Private key does not match the public certificate\n");
		abort();
	}
}

void https_server(int port) {
	int sock, *client_sock;
	struct sockaddr_in addr, *client_addr;
	socklen_t addr_len = sizeof(struct sockaddr_in);
	int reuse_addr = 1;
	struct rlimit max_fds;
	pthread_t thread;
	SSL_CTX *ctx;

	char certFile;
	char keyFile;

	ctx = InitServerCTX();
	LoadCertificates(ctx, certFile, keyFile);

	/* Create socket for IPv4 only */
	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
		hurl_debug(__func__, "Failed to create socket.");
		return;
	}
	/* Enable reuse of port number */
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse_addr, sizeof(int));

	/* Change max number of file descriptors */
	getrlimit(RLIMIT_NOFILE, &max_fds);
	if (max_fds.rlim_cur < max_fds.rlim_max) {
		/* Change limit */
		max_fds.rlim_cur = max_fds.rlim_max;
		hurl_debug(__func__, "Changing max FDs to %d", max_fds.rlim_max);
		setrlimit(RLIMIT_NOFILE, &max_fds);
	}

	/* Bind socket to localhost:53 */
	bzero(&addr, sizeof(struct sockaddr_in));
	addr.sin_family = AF_INET;
	addr.sin_port = htons((uint16_t) port);
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	if (bind(sock, (struct sockaddr *) &addr, addr_len) == -1) {
		hurl_debug(__func__, "Failed to bind socket: %s", strerror(errno));
		return;
	}

	/* Put socket into listening mode */
	if (listen(sock, 1024) == -1) {
		hurl_debug(__func__, "Failed to listen on socket.");
		return;
	}

	for (;;) {
		client_addr = malloc(sizeof(struct sockaddr_in));
		client_sock = malloc(sizeof(int));
		SSL *ssl;
		if ((*client_sock = accept(sock, (struct sockaddr *) client_addr,
				&addr_len)) == -1) {
			hurl_debug(__func__, "Failed to accept client: %s.",
					strerror(errno));
			continue;
		}

		hurl_debug(__func__, "Client connected.");
		/* Handle HTTP request in separate thread. */
		pthread_create(&thread, NULL, http_handler, client_sock);
	}

}
